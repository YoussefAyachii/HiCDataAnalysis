---
---
title: "HiC_Data_Analysis"
author: "YoussefAyachi"
date: "28/05/2021"
output: html_document
---

# Initialization
Loading packages 
```{r Libraries : loading}
library(tidyverse)
library(remotes)
library(isotone)
library(caTools)
library(R.utils)
library(data.table)
library(nortest)
library(gridExtra)
library(R.utils)
library(data.table)
library(ggpubr)
library(lemon)
library(Matrix)
library(FitHiC)

```

Defining Directory Paths
```{r Variables : Defining paths' variables }
Dir_Project<-"/Users/bottimacintosh/Documents/M1_CMB/Internship TAGC/Project/"
Dir_Finaltables<-paste0(Dir_Project,"Project.Inputs/Finaltables/")
Dir_Sparsetables<-paste0(Dir_Project,"Project.Inputs/Sparsetables/")
Dir_Figures<-paste0(Dir_Project,"Project.Outputs/Figures/")

Dir_WTNS<-paste0(Dir_Project,"Project.Outputs/WTNS/")
Dir_WTS<-paste0(Dir_Project,"Project.Outputs/WTS/")
Dir_KONS<-paste0(Dir_Project,"Project.Outputs/KONS/")
Dir_KOS<-paste0(Dir_Project,"Project.Outputs/KOS/")
Dir_PUBLISHED<-paste0(Dir_Project,"Project.Outputs/PUBLISHED/")

```

start point : sparse matrix 608x608 (nb of bins)= ipf normalized interaction scores between bins 
```{r Reading : read.table sparse matrices , include=FALSE , message = FALSE}
wtns.sparsetable<-read.table(paste0(Dir_Sparsetables,"wtns_rect_ipf.txt") , header = TRUE , sep="\t" , dec=".")
wts.sparsetable<-read.table(paste0(Dir_Sparsetables,"wts_rect_ipf.txt" ), header = TRUE , sep="\t" , dec=".")
kons.sparsetable<-read.table(paste0(Dir_Sparsetables,"kons_rect_ipf.txt") , header = TRUE , sep="\t" , dec=".")
kos.sparsetable<-read.table(paste0(Dir_Sparsetables,"kos_rect_ipf.txt"), header = TRUE , sep="\t" , dec=".")
published.sparsetable<-read.table(paste0(Dir_Sparsetables,"published_rect_ipf.txt") , header = TRUE , sep="\t" , dec=".")
```

finaltables = table of nine columns {strand1	chr1;	pos1;	fres1;	strand2;	chr2;	pos2;	fres2;	score}. 
```{r Reading : read.table finaltables include=FALSE echo=FALSE}
wtns.finaltable<-read.table(paste0(Dir_Finaltables,"wtns.finaltable.txt"), header = TRUE , sep="\t" , dec=".")
wts.finaltable<-read.table(paste0(Dir_Finaltables,"wts.finaltable.txt") , header = TRUE , sep="\t" , dec=".")
kons.finaltable<-read.table(paste0(Dir_Finaltables,"kons.finaltable.txt") , header = TRUE , sep="\t" , dec=".")
kos.finaltable<-read.table(paste0(Dir_Finaltables,"kos.finaltable.txt") , header = TRUE , sep="\t" , dec=".")
published.finaltable<-read.table(paste0(Dir_Finaltables,"published.finaltable.txt"), header = TRUE , sep="\t" , dec=".")
```

Useful Variables 
```{r Variables : Defining useful variables}
vec_dataset_names<-c("WTNS", "WTS", "KNOS", "KOS", "PUBLISHED")
vec_dataset_directories<-c(Dir_WTNS, Dir_WTS, Dir_KONS, Dir_KOS, Dir_PUBLISHED)
list_finaltables<-list(wtns.finaltable,wts.finaltable,kons.finaltable, kos.finaltable, published.finaltable)
vec_finaltable_name<-c("wtns.finaltable.txt" , "wts.finaltable.txt" , "kons.finaltable.txt", "kos.finaltable.txt","published.finaltable.txt")
vec_sample_names<-c("ALLMATRIX", "CLUSTER", "KB100" , "KB100_NO_OAS")
palette_color<-"Set1"
list_sparse_matrices<-list(wtns.sparsetable,wts.sparsetable,kons.sparsetable,kos.sparsetable, published.sparsetable)
vec_sparse_matrices_names<-c("wtns.sparsetable","wts.sparsetable","kons.sparsetable","kos.sparsetable", "published.sparsetable")
```

# I. FitHiC 

FitHiC::FitHiC function on our data. This function needs two inputs : an interact file and a fragment file. Here we build these two inputs from our datasets (.finaltable).  

#### FitHiC::FitHiC Fragments Argument

```{r Function : FitHiC::FitHiC Fragments Argument}
GetFragmentsFile<-function(INPUT_TABLE,CHR_NB){

#duplicate
finaltable_tempo<-INPUT_TABLE

#initiation
id_fragments<-unique(c(finaltable_tempo[,3] , finaltable_tempo[,7]))
col_marginalizedContactCount<-vector("numeric",length=length(id_fragments))

#marginalizedContactCount 
for(i in 1:length(id_fragments)){
  id_concerned<-id_fragments[i]
  id_unique_table<-finaltable_tempo %>% filter(pos1==id_concerned | pos2 ==id_concerned ) %>% mutate(score=round(score)) 
  col_marginalizedContactCount[i]<-sum(id_unique_table[,9])
  }
  
#columns : 1 , 2 , 5
col_chr<-rep(CHR_NB,length(id_fragments))
col_extrafield<-rep(0,length(id_fragments))
col_mappable<-rep(1,length(id_fragments))

#table 
FRAGMENTS_TABLE<-data.frame(col_chr,col_extrafield,id_fragments,col_marginalizedContactCount,col_mappable)

return (FRAGMENTS_TABLE)
}
```

#### FitHiC::FitHiC Interactions Argument

```{r Function : FitHiC::FitHiC Interactions Argument}
GetInteractionsFile<-function(INPUT_TABLE,CHR_NB){

#duplicate
finaltable_tempo<-INPUT_TABLE

#building 
col_chr<-rep(CHR_NB,nrow(finaltable_tempo))
col_finalCount<-as.integer(finaltable_tempo[,9])

#table
INTERACTIONS_TABLE<-data.frame(col_chr,finaltable_tempo[,3],col_chr,finaltable_tempo[,7],col_finalCount)
return(INTERACTIONS_TABLE)
}
```

#### FitHiC::FitHiC Global Function
This function needs compressed files as input (.gzip)
```{r Function : FitHiC::FitHiC Global Function}
FitHiCLocalFucntion<-function(FRAGMENTS_TABLE,INTERACTIONS_TABLE,FRAGMENTS_PATH,INTERACTIONS_PATH,OUTPUT_PATH){
fwrite(FRAGMENTS_TABLE,compress="gzip", file = FRAGMENTS_PATH, quote = FALSE, sep='\t', row.names =       FALSE, col.names = FALSE)
fwrite(INTERACTIONS_TABLE,compress="gzip", file = INTERACTIONS_PATH, quote = FALSE, sep='\t',            row.names = FALSE, col.names = FALSE) 
FitHiC::FitHiC(FRAGMENTS_PATH,INTERACTIONS_PATH, outdir = OUTPUT_PATH )
}
```

Execution FitHiC::FitHiC on the four datasets
```{r Execution : FitHiC::FitHiC on the five datasets , include = FALSE}

for(i in 1:5){
  fragments_fullpath<-paste(vec_dataset_directories[i] , "fragments_table_wts.txt.gz", sep="")
  interactions_fullpath_wts<-paste (vec_dataset_directories[i] , "interactions_table_wts.txt.gz",sep="")
  output_path<-vec_dataset_directories[i]
  from_list_to_df<-as.data.frame(list_finaltables[i])
  
  FitHiCLocalFucntion(GetFragmentsFile(from_list_to_df,12),GetInteractionsFile(from_list_to_df,12),fragments_fullpath,interactions_fullpath_wts,output_path)
}
```

The execution of FitHiC::FitHiC leads to 4 outputs : 
-fithic.pass1
-fithic.pass2
-spline.pass1 (zipped)
-spline.pass2 (zipped)

Unzip the spline files.
```{r Function : Unzip FitHiC outputs }
GetUnzippedFitHiCResults<- function (WORKING_DIRECTORY){

  setwd(WORKING_DIRECTORY)
  spline_pass_1<-fread(".spline_pass1.significances.txt.gz")
  spline_pass_2<-fread(".spline_pass2.significances.txt.gz")  
  write.table(x=spline_pass_1, ".spline_pass1.significances.txt",sep="\t")
  write.table(x=spline_pass_2, ".spline_pass2.significances.txt",sep="\t")

}
```

```{r Execution : Unzip FitHiC outputs}
for(i in 1:length(vec_dataset_directories)){GetUnzippedFitHiCResults(vec_dataset_directories[i])}

```

Here is an example of what we get : FitHiC outputs.
```{r Execution : Example}
example_to_show_1<-read.table(paste0(Dir_PUBLISHED,".fithic_pass1.txt") , header = TRUE)
example_to_show_2<-read.table(paste0(Dir_PUBLISHED,".spline_pass2.significances.txt") , header = TRUE)
head(example_to_show_1,5)
head(example_to_show_2,5)
```


# II. Bed Graphs 
A bedgraph is a 2D  graph that shows the interaction ofe one specific bin with all the others. It is read by a genome browser as USCS or WashU genome browser. 
The inputs of the following function are the finaltables.
We have chosen six 5 kilobase bins located in the OAS3 promoter region. 

```{r Function : Building BedGraph inputs , echo=FALSE}
GetBedGraph<-function(OUTPUT_DIRECTORY , INPUT_TABLE , OUTPUT_NAME_TABLE.txt , CHR_NB, BIN_START, BIN_LENGTH){

setwd(OUTPUT_DIRECTORY)
imported_data<-INPUT_TABLE

#filter with our bin 
imported_data <- imported_data %>% filter ( (pos1==BIN_START) | (pos2==BIN_START)) 

a<-imported_data %>% filter (pos2==BIN_START) %>% select("strand1", "chr1"  ,  "pos2" ,   "fres1" ,  "strand2" ,"chr2",    "pos1" ,   "fres2" , "score")

b<-imported_data %>% filter (pos1==BIN_START) %>% select("strand1", "chr1"  ,  "pos1" ,   "fres1" ,  "strand2" ,"chr2",    "pos2" ,   "fres2" , "score")

colnames(a)<-c("strand1", "chr1"  ,  "pos1" ,   "fres1" ,  "strand2" ,"chr2",    "pos2" ,   "fres2" , "score")

imported_data_filtered<-rbind(a,b)

#column 1 : chr
bed_graph_col1<-rep(CHR_NB, nrow(imported_data_filtered))

#column 2 : lower starting region 
bed_graph_col2<-imported_data_filtered[,7]

#column 3 : lower end region 
bed_graph_col3<-imported_data_filtered[,7]+BIN_LENGTH

#column 4 : Upper region and score : ex : chr1:758539-760203,2
score<-imported_data_filtered[,9]
bed_graph_col4<-score


bed_graph_finaltable<-data.frame(bed_graph_col1,bed_graph_col2,bed_graph_col3,bed_graph_col4)
write.table(bed_graph_finaltable , OUTPUT_NAME_TABLE.txt , sep='\t' , quote = FALSE, row.names =       FALSE, col.names = FALSE)
}

```

```{r Execution : on 6 bins, echo=FALSE }
vec_bins_of_interest_for_bedgraphs<-c(113355000, 113360000, 113365000, 113370000, 113375000, 113380000)

for (i in 1:length(list_finaltables)){
  working.table<-as.data.frame(list_finaltables[i])
  working.dir<-vec_dataset_directories[i]
  
  for(j in 1:length(vec_bins_of_interest_for_bedgraphs)){
    bedgraph_output_name<-paste("Bedgraph_",vec_bins_of_interest_for_bedgraphs[j],".bed",sep="")
    GetBedGraph(working.dir, working.table, bedgraph_output_name, "chr12", vec_bins_of_interest_for_bedgraphs[j],5000)
  }}

```


# III. long_range file 

## 1.  Get Long_range file from spline1-2
```{r Function : Get the long_range tables from spline1-2 (FitHiC outputs) - WashU input}
GetLongRangeFile<-function(CHR_NB, BIN_LENGTH_Kb, DIRECTORY_INPUT_TABLE ,  SPLINE_TABLE.txt , OUTPUT_NAME_TABLE.txt , MIN_SCORE , LOG) {

setwd(DIRECTORY_INPUT_TABLE)
working_table<-read.table(SPLINE_TABLE.txt, header=TRUE, sep="\t" )

#column 1 : chr
long_range_col1<-rep(paste("chr",CHR_NB), nrow(working_table))

#column 2 : lower starting region 
long_range_col2<-working_table[,2]

#column 3 : lower end region 
long_range_col3<-working_table[,2]+BIN_LENGTH_Kb

if(missing(LOG)){
score<-round(-log10(working_table[,7]),0)
score[is.infinite(score)]<-0
score[score==0]<-min(score[!score==0])
}else{
score<-round(-log2(working_table[,7]),0)
score[is.infinite(score)]<-0
score[score==0]<-min(score[!score==0])
}

#score correction
score<-round(-log10(working_table[,7]),0)
score[is.infinite(score)]<-0
#replace score = 0 by score = 0.5

#column 4 : Upper region and score : ex : chr1:758539-760203,2
long_range_col4<-paste(paste("chr",CHR_NB),":",working_table[,4],"-",working_table[,4]+BIN_LENGTH_Kb,",",score,sep="")

long_range_finaltable<-data.frame(long_range_col1,long_range_col2,long_range_col3,long_range_col4)

#If we don't want 0 as scores : Eliminate all the rows with score = 0 
if(MIN_SCORE==1){
long_range_finaltable<-data.frame(long_range_col1,long_range_col2,long_range_col3,long_range_col4,score)
colnames(long_range_finaltable)<-c(paste("col",1:5 , sep=""))
long_range_finaltable <- long_range_finaltable %>% filter(!(col5==0)) %>% select (col1 , col2 , col3 , col4)
}

write.table(long_range_finaltable , OUTPUT_NAME_TABLE.txt , sep='\t' , quote = FALSE, row.names =       FALSE, col.names = FALSE)
}
```

```{r Execution : Get the long_range tables from spline1-2 (FitHiC outputs)}

vec_spline_file_names<-c(".spline_pass1.significances.txt.gz" , ".spline_pass2.significances.txt.gz")

for(i in 1:length(vec_dataset_names)){
  for(j in 1:length(vec_spline_file_names)){ #for each spline file
GetLongRangeFile(12 , 5000 , vec_dataset_directories[i] , vec_spline_file_names[j] , paste("long_range_from_spline_",j,"_",vec_dataset_names[i],".bed",sep="") , 0)
  }
}

```



## 2.  Get Long_range file from spline1-2 and filtred for certain bins of interest
It consists in filtering long_range_table for bins of interest (vec_bins_of_interest: 70000-75000 , 75000-80000 , 80000-85000). Thus, For each of the 3 chosen bins, we will get 5 tables, each one belonging to one cell poupulation (wtns, wts, kons, kos and published. 

```{r Function : Get the long_range tables of a specific bin}

GetLongRangeFileSpeceficBin <- function (BIN_OF_INTEREST_START) {
  for(i in 1:length(vec_dataset_directories)){
    setwd(vec_dataset_directories[i])
    for(j in 1:length(vec_spline_file_names)){
      working_table<-read.table(paste("long_range_from_spline_",j,"_",vec_dataset_names[i],".bed",sep=""),sep="\t",header = FALSE, dec=".")
      bin_filtered_working_table<-working_table %>% filter ( (V3==BIN_OF_INTEREST_START) | (V4==BIN_OF_INTEREST_START))
      write.table(bin_filtered_working_table, paste("long_range_from_spline",j,"_",vec_dataset_names[i],BIN_OF_INTEREST_START,".bed",sep=""))
      }
    }
  }

```

```{r Execution : Get the long_range tables of a specific bin}

for(i in length(vec_dataset_directories)){
  setwd(vec_dataset_directories[i])
  for(j in 1:length(vec_bins_of_interest_for_bedgraphs)){
    write.table(GetLongRangeFileSpeceficBin(vec_bins_of_interest_for_bedgraphs[j]))
    }
}

```

## 3.  Get Long_range file from finaltables 

```{r Function : Get the long_range tables on finaltables}
#EXECUTION on each  fithic output (not the splines outputs

GetLongRangeFileFromFinaltable<-function(CHR_NB, BIN_LENGTH_Kb, DIRECTORY_INPUT_TABLE ,  FINALTABLE , OUTPUT_NAME_TABLE.txt , MIN_SCORE , LOG) {

setwd(DIRECTORY_INPUT_TABLE)
working_table<-read.table(FINALTABLE, header=TRUE, sep="\t" )

#column 1 : chr
long_range_col1<-rep(paste("chr",CHR_NB), nrow(working_table))

#column 2 : lower starting region 
long_range_col2<-working_table[,3]

#column 3 : lower end region 
long_range_col3<-working_table[,3]+BIN_LENGTH_Kb

#column 4 : Upper region and score : ex : chr1:758539-760203,2
score<-working_table[,9]
long_range_col4<-paste("chr12",":",working_table[,7],"-",working_table[,7]+BIN_LENGTH_Kb,",",score,sep="")

long_range_finaltable<-data.frame(long_range_col1,long_range_col2,long_range_col3,long_range_col4)

#If we don't want 0 as scores : Eliminate all the rows with score = 0 
if(MIN_SCORE==1){
  long_range_finaltable<-data.frame(long_range_col1,long_range_col2,long_range_col3,long_range_col4,score)
  colnames(long_range_finaltable)<-c(paste("col",1:5 , sep=""))
  long_range_finaltable <- long_range_finaltable %>% filter(!(col5==0)) %>% select (col1 , col2 , col3 , col4)
  }

write.table(long_range_finaltable , OUTPUT_NAME_TABLE.txt , sep='\t' , quote = FALSE, row.names =       FALSE, col.names = FALSE)
}

```

```{r Execution : Get the long_range tables on finaltables}
#EXECUTION on each fithic file (1,2) of each dataset (n=5)

for(i in 1:length(vec_dataset_names)){ 
GetLongRangeFileFromFinaltable(12 , 5000 , Dir_Finaltables , vec_finaltable_name[i] , paste("long_range_from_finaltable_",vec_dataset_names[i],".bed",sep="") , 0)
}

```

## 4. Get Long_range file from finaltables filtred on bins of interest

```{r Function : Get the long_range table from finaltables for specific bins}
# Same for specific bins

GetLongRangeFileFromFinaltableSpeceficBin <- function (BIN_OF_INTEREST_START) {
  for(i in 1:length(vec_dataset_directories)){
    setwd(Dir_Finaltables)
    working_table<-as.data.frame(list_finaltables[i])
    bin_filtered_working_table<-working_table %>% filter ( (pos1==BIN_OF_INTEREST_START) | (pos2==BIN_OF_INTEREST_START))
      
    setwd(vec_dataset_directories[i])
    write.table(bin_filtered_working_table, paste("long_range_from_finaltable_",vec_dataset_names[i],BIN_OF_INTEREST_START,".bed",sep=""))
    }
  }

```

```{r Execution : LONG_RANGE for specific bins}
for(k in 1:length(vec_dataset_directories)){
  setwd(vec_dataset_directories[k])
  for(j in 1:length(vec_bins_of_interest_for_bedgraphs)){
    write.table(GetLongRangeFileFromFinaltableSpeceficBin(vec_bins_of_interest_for_bedgraphs[j]))
    }
  }

```


# IV. Descriptive Statistics : Bulding Score Tables For Each Sample 

## 1. AllMatrix And Cluster data manipulation

### a. Build a sparse matrix for the cluster (AllMatrix, Cluster , 100kb , 100kb No OAS ) from the sparse tables (608x608)

```{r Definition : Define Sparse Matrices as dataframes}

AllMatrix_Wtns_sparse_matrix<-as.data.frame(as.matrix(wtns.sparsetable))
AllMatrix_Wts_sparse_matrix<-as.data.frame(as.matrix(wts.sparsetable))
AllMatrix_Kons_sparse_matrix<-as.data.frame(as.matrix(kons.sparsetable)) 
AllMatrix_Kos_sparse_matrix<-as.data.frame(as.matrix(kos.sparsetable))
AllMatrix_Published_sparse_matrix<-as.data.frame(as.matrix(published.sparsetable))

```

```{r Function : Get Sparse Matrix of defined bins interval}
GetSparseOfInterest<- function(FULL_SPARSE_TABLE, CONDITION, SAMPLE_NAME, BIN_LENGTH, CHR_NB, LOWER_BIN_START, UPPER_BIN_START ) {

working_sparse<-FULL_SPARSE_TABLE

colnames_of_interest<-colnames(working_sparse)
lower_bin<- paste("chr12_",LOWER_BIN_START,"_",LOWER_BIN_START+BIN_LENGTH,sep="")
upper_bin<- paste("chr12_",UPPER_BIN_START,"_",UPPER_BIN_START+BIN_LENGTH,sep="")

index_lower_bin<-match(lower_bin,colnames_of_interest)
index_upper_bin<-match(upper_bin,colnames_of_interest)
colnames_of_interest<-colnames_of_interest[index_lower_bin:index_upper_bin]

working_sparse<- as.matrix(working_sparse)
working_sparse<- as.data.frame(working_sparse)
working_sparse<- working_sparse %>% filter(row.names(working_sparse) %in% colnames_of_interest) %>% select(colnames_of_interest)

return(working_sparse)
}
```

```{r Execution : Get Sparse Matrix for a defined bins interval}
#Cluster
Cluster_Wtns_sparse_matrix<-GetSparseOfInterest(AllMatrix_Wtns_sparse_matrix,"wts","Cluster",5000,"chr12",113340000,113450000)
Cluster_Wts_sparse_matrix<-GetSparseOfInterest(AllMatrix_Wts_sparse_matrix,"wts","Cluster",5000,"chr12",113340000,113450000)
Cluster_Kons_sparse_matrix<-GetSparseOfInterest(AllMatrix_Kons_sparse_matrix,"wts","Cluster",5000,"chr12",113340000,113450000)
Cluster_Kos_sparse_matrix<-GetSparseOfInterest(AllMatrix_Kos_sparse_matrix,"wts","Cluster",5000,"chr12",113340000,113450000)
Cluster_Published_sparse_matrix<-GetSparseOfInterest(AllMatrix_Published_sparse_matrix,"wts","Cluster",5000,"chr12",113340000,113450000)

```

### b. Get Sparse Matrix vectors

```{r Function : Get Sparse Matrix Vector : From a Sparse MAtrix (Symmetric Matrix), get one Vector Containing 1/2 Of The Cells And No Diagonal Cells : From left to the right process}
#Idea : From the left to the right, in the right half of the matrix , build two vectors of coordinates X and Y. Then for each i of X and Y , search for the cell of the sparse matrix. 

GetVectorFromMatrix<-function(SPARSE_MATRIX){

  working_sparse<-SPARSE_MATRIX
  rownames_matrix<-rownames(working_sparse)
  colnames_matrix<-colnames(working_sparse)

  X_vec<-vector()
  for (i in 1:nrow(working_sparse)){
    X_vec<-c(X_vec,rep(i,length(i:ncol(working_sparse))-1))
  }
  
  Y_vec<-vector()
  for(i in 2:ncol(working_sparse)){
      Y_vec<-c(Y_vec,i:ncol(working_sparse))
  }
 
  matrix_vector<-vector()
  for(i in 1:length(X_vec)){
    matrix_vector<-c(matrix_vector,working_sparse[X_vec[i],Y_vec[i]])
  }

  return(matrix_vector)
}

```

```{r Exectuion : VERY LONG EXECUTION : Get sparse matrix vector }

#AllMatrix
AllMatrix_Wtns_Sparse_Matrix_Vector <- GetVectorFromMatrix(AllMatrix_Wtns_sparse_matrix)
AllMatrix_Wts_Sparse_Matrix_Vector <- GetVectorFromMatrix(AllMatrix_Wts_sparse_matrix)
AllMatrix_Kons_Sparse_Matrix_Vector <- GetVectorFromMatrix(AllMatrix_Kons_sparse_matrix)
AllMatrix_Kos_Sparse_Matrix_Vector <- GetVectorFromMatrix(AllMatrix_Kos_sparse_matrix)
AllMatrix_Published_Sparse_Matrix_Vector <- GetVectorFromMatrix(AllMatrix_Published_sparse_matrix)

AllMatrix_Wtns_Sparse_Matrix_Vector <-unlist(AllMatrix_Wtns_Sparse_Matrix_Vector)
AllMatrix_Wts_Sparse_Matrix_Vector <-unlist(AllMatrix_Wts_Sparse_Matrix_Vector)
AllMatrix_Kons_Sparse_Matrix_Vector <-unlist(AllMatrix_Kons_Sparse_Matrix_Vector)
AllMatrix_Kos_Sparse_Matrix_Vector<-unlist(AllMatrix_Kos_Sparse_Matrix_Vector)
AllMatrix_Published_Sparse_Matrix_Vector <-unlist(AllMatrix_Published_Sparse_Matrix_Vector)

#Cluster
Cluster_Wtns_Sparse_Matrix_Vector <- GetVectorFromMatrix(Cluster_Wtns_sparse_matrix)
Cluster_Wts_Sparse_Matrix_Vector <- GetVectorFromMatrix(Cluster_Wts_sparse_matrix)
Cluster_Kons_Sparse_Matrix_Vector <- GetVectorFromMatrix(Cluster_Kons_sparse_matrix)
Cluster_Kos_Sparse_Matrix_Vector <- GetVectorFromMatrix(Cluster_Kos_sparse_matrix)
Cluster_Published_Sparse_Matrix_Vector <- GetVectorFromMatrix(Cluster_Published_sparse_matrix)

```

### c. Clean Sparse Matrices Vector

We replace 0 by min to not get NAs in Full Change vectors computed further. 
```{r Function : Cleaning All Sparse Matrices vector from All Inf , -Inf and Replace all 0 by min }

GetCleanVector<- function (SPARSE_VECTOR){
  working.vector<-SPARSE_VECTOR
  working.vector[working.vector==Inf]<-max(working.vector[working.vector!=(Inf)])
  working.vector[working.vector==-Inf]<-min(working.vector[working.vector!=(-Inf)])
  working.vector[working.vector==0]<-min(working.vector[working.vector!=(0)])
  return(working.vector)
}

#Use list as an input (Not practical in long executions: For AllMatrix Vectors)
GetCleanVectorFromList<-function(LIST_OF_SPARSE_VECTORS){
  for(i in 1:length(LIST_OF_SPARSE_VECTORS)){
    LIST_OF_SPARSE_VECTORS[i]<-GetCleanVector(LIST_OF_SPARSE_VECTORS[i])
  }
  return(LIST_OF_SPARSE_VECTORS)
}

```

```{r Execution : Cleaning All Sparse Matrices vector from All Inf , -Inf and Replace all 0 by min}

#All Matrix 
AllMatrix_Wtns_Sparse_Matrix_Vector <- GetCleanVector(AllMatrix_Wtns_Sparse_Matrix_Vector)
AllMatrix_Wts_Sparse_Matrix_Vector <- GetCleanVector(AllMatrix_Wts_Sparse_Matrix_Vector)
AllMatrix_Kons_Sparse_Matrix_Vector <- GetCleanVector(AllMatrix_Kons_Sparse_Matrix_Vector)
AllMatrix_Kos_Sparse_Matrix_Vector <- GetCleanVector(AllMatrix_Kos_Sparse_Matrix_Vector)
AllMatrix_Published_Sparse_Matrix_Vector <- GetCleanVector(AllMatrix_Published_Sparse_Matrix_Vector)

#Cluster
Cluster_Wtns_Sparse_Matrix_Vector <- GetCleanVector(Cluster_Wtns_Sparse_Matrix_Vector)
Cluster_Wts_Sparse_Matrix_Vector <- GetCleanVector(Cluster_Wts_Sparse_Matrix_Vector)
Cluster_Kons_Sparse_Matrix_Vector <- GetCleanVector(Cluster_Kons_Sparse_Matrix_Vector)
Cluster_Kos_Sparse_Matrix_Vector <- GetCleanVector(Cluster_Kos_Sparse_Matrix_Vector)
Cluster_Published_Sparse_Matrix_Vector <- GetCleanVector(Cluster_Published_Sparse_Matrix_Vector)



```

### d. Build Score Table for each Sample with Full Change columns.

columns are : WTNS, WTS, KONS, KOS, PUBLISHED, FC_wts_wtns, FC_kos_kons, binA and binB 
Each row represent an interaction between binA and binB.
```{r Function: Add interactions (A_BINS , B_BINS) columns to FC_df_densities table}
#input = sparse matrix 
#output = 2 vectors : binA and bin B : 2 columns to add in FC_df_densities

GetBinInteractionVetors<-function(SPARSE_MATRIX){

  working_sparse<-SPARSE_MATRIX
  rownames_matrix<-rownames(working_sparse)
  colnames_matrix<-colnames(working_sparse)

  A_vec<-vector()
  for (i in 1:nrow(working_sparse)){
    A_vec<-c(A_vec,rep(rownames_matrix[i],length(i:ncol(working_sparse))-1))
  }
  
  B_vec<-vector()
  for(i in 2:ncol(working_sparse)){
      B_vec<-c(B_vec,i:ncol(working_sparse))
  }
  B_vec_bis<-vector()
  for(i in 1:length(B_vec)){ B_vec_bis<-c(B_vec_bis,colnames_matrix[B_vec[i]])}
  
  return(list(A_vec , B_vec_bis))
}

```

```{r Execution -LONG EXECUTION- : Build Score Table for each sample}
FC_DF_COLNAMES<- c("WTNS","WTS","KONS","KOS","PUBLISHED","FC_wts_wtns","FC_kos_kons" , "FC_wtns_kons","FC_wts_kos", "A_BIN","B_BIN")

#AllMatrix
AllMatrix_Score_df <- data.frame(
  WTNS=AllMatrix_Wtns_Sparse_Matrix_Vector,
  WTS=AllMatrix_Wts_Sparse_Matrix_Vector,
  KONS=AllMatrix_Kons_Sparse_Matrix_Vector,
  KOS=AllMatrix_Kos_Sparse_Matrix_Vector,
  PUNLISHED=AllMatrix_Published_Sparse_Matrix_Vector,
  FC_wts_wtns=log2(AllMatrix_Wts_Sparse_Matrix_Vector/AllMatrix_Wtns_Sparse_Matrix_Vector),
  FC_kos_kons=log2(AllMatrix_Kos_Sparse_Matrix_Vector/AllMatrix_Published_Sparse_Matrix_Vector),
  FC_wtns_kons=log2(AllMatrix_Wtns_Sparse_Matrix_Vector/AllMatrix_Kons_Sparse_Matrix_Vector),
  FC_wts_kos=log2(AllMatrix_Wts_Sparse_Matrix_Vector/AllMatrix_Kos_Sparse_Matrix_Vector),
  A_BIN=(GetBinInteractionVetors(AllMatrix_Wtns_sparse_matrix)[1]),
  B_BIN=(GetBinInteractionVetors(AllMatrix_Wtns_sparse_matrix)[2])
)
colnames(AllMatrix_Score_df)<-FC_DF_COLNAMES


#Cluster

Cluster_Score_df<-data.frame(
  WTNS=Cluster_Wtns_Sparse_Matrix_Vector, 
  WTS=Cluster_Wts_Sparse_Matrix_Vector, 
  KONS=Cluster_Kons_Sparse_Matrix_Vector, 
  KOS=Cluster_Kos_Sparse_Matrix_Vector, 
  PUBLISHED=Cluster_Published_Sparse_Matrix_Vector,
  FC_wts_wtns=log2(Cluster_Wts_Sparse_Matrix_Vector/Cluster_Wtns_Sparse_Matrix_Vector),
  FC_kos_kons=log2(Cluster_Kos_Sparse_Matrix_Vector/Cluster_Kons_Sparse_Matrix_Vector),
  FC_wtns_kons=log2(Cluster_Wtns_Sparse_Matrix_Vector/Cluster_Kons_Sparse_Matrix_Vector),
  FC_wts_kos=log2(Cluster_Wts_Sparse_Matrix_Vector/Cluster_Kos_Sparse_Matrix_Vector),
  A_BIN=GetCleanVector(GetBinInteractionVetors(Cluster_Wtns_sparse_matrix)[[1]]),
  B_BIN=GetCleanVector(GetBinInteractionVetors(Cluster_Wtns_sparse_matrix)[[2]]))

colnames(Cluster_Score_df)<-FC_DF_COLNAMES

```


## 2. KB100 and KB100_NO_OAS

```{r Function : Get Sparse Matrix And Sparse Matrix Vector of Specified Bin }

GetSparseMatrixAndVectorOfSpecifiedBin<-function(  SPARSE_MATRIX , LOWER_BIN_START , BIN_LENGTH_OF_INTEREST ) {

lower_bin_start<-LOWER_BIN_START
upper_bin_start<-lower_bin_start + BIN_LENGTH_OF_INTEREST
sparse_matrix<-SPARSE_MATRIX


lower_bin<- paste("chr12_",format(lower_bin_start,scientific=FALSE) ,"_",format(lower_bin_start+5000,scientific=F),sep="")
upper_bin<- paste("chr12_",format(upper_bin_start,scientific=FALSE),"_",format(upper_bin_start+5000,scientific=FALSE),sep="")


# total list of bins between lower_bin and upper_bin : lower_bin_start_vector

lower_bin_temporarly<-lower_bin_start
bin_nb_in_interval<-0
lower_bin_start_vector<-vector("numeric")
lower_bin_start_vector<-append(lower_bin_start_vector,lower_bin_temporarly)

while(lower_bin_temporarly < upper_bin_start){
bin_nb_in_interval<-bin_nb_in_interval+1
lower_bin_temporarly<-format(as.numeric(lower_bin_temporarly)+5000,scienbtific=FALSE)
lower_bin_start_vector<-append(lower_bin_start_vector,format(as.numeric(lower_bin_temporarly),scientific=FALSE))
}



# generate vector of rownames of interest 

rownames_of_interest<-vector()
for( j in 1:bin_nb_in_interval){
rownames_of_interest <- append(rownames_of_interest, paste("chr12_",
                                                           as.character(lower_bin_start_vector[j]),
                                                           "_",
                                                           as.character(format(as.numeric(lower_bin_start_vector[j])+5000, scientific=FALSE)),sep="")) 
}

# Get the sparse matrix of each bin of 100kb
#= filter the sparse matrix with the rownames takes. 

tempo_sparse_matrix<-sparse_matrix %>% filter (row.names(sparse_matrix) %in% rownames_of_interest) %>% select ( all_of(rownames_of_interest))

# Get bins of interactions in the same order than the vector sparse matrix : bin_A and bin_B columns 

list_A<-GetBinInteractionVetors(tempo_sparse_matrix)[[1]]
list_B<-GetBinInteractionVetors(tempo_sparse_matrix)[[2]]

# Get the sparse vector of each 100kb sparse matrix

tempo_sparse_vector<-GetVectorFromMatrix(tempo_sparse_matrix)

return(list(tempo_sparse_matrix,tempo_sparse_vector,list_A, list_B))
}

```

Our Bin length = 100 000
Our lower bin start is the first row name bin : 111875000

```{r Function : GetAllBinStartEach100KB}
GetAllBinStartEachFixedInterval<-function(lower_allregion_limit,upper_allregion_limit,BIN_LENGTH,INITIAL_BIN_LENGTH){
  tempo_upper_limit<-lower_allregion_limit
  vec_start_bins<-vector()

  while(tempo_upper_limit<upper_allregion_limit){
    vec_start_bins<-c(vec_start_bins,tempo_upper_limit)
    tempo_upper_limit<-tempo_upper_limit+BIN_LENGTH
  }
  vec_start_big_bins<-vec_start_bins
return(vec_start_big_bins)
}

```

```{r Execution : GetAllBinStartEachFixedInterval}

Start_100KB_BINS<-GetAllBinStartEachFixedInterval(111875000, 114910578 , 100000, 5000)

```

Our Bin length = 100 000.
Our lower bin start is the first row name bin : 111875000.
Becarfull , the last bin of 100Kb which is starting from 114875000. Thus, When aligning heatmaps with genome sequece, use the upper limit : 114875000-. OAS_cluster removed for KB100_NO_OASis equal to two bins. 

```{r Function : Get KB100_Score_df  and its vectors}

GetKB100ScoreTable<-function(WITH_OAS){


if(WITH_OAS==FALSE){
Start_100KB_BINS<-GetAllBinStartEachFixedInterval(111875000, 114910578 , 100000, 5000)

}else{ #remove OAS CLuster 
Start_100KB_BINS<-Start_100KB_BINS[!Start_100KB_BINS %in% c(113475000,113575000)]
}

df_list<-list()
tempo_df<-data.frame()

for(i in 1:length(list_sparse_matrices)){
working_sparse<-list_sparse_matrices[[i]]

final_tempo_sparse_vec<-vector()
final_tempo_Abin_vec<-vector()
final_tempo_Bbin_vec<-vector()


  for( j in length(Start_100KB_BINS)-1){
    tempo_output<-GetSparseMatrixAndVectorOfSpecifiedBin(working_sparse, Start_100KB_BINS[j], 100000)
    tempo_sparse_vec<-tempo_output[[2]]
    tempo_Abin_vec<-tempo_output[[3]]
    tempo_Bbin_vec<-tempo_output[[4]]
    #add to the corresponding data.fame
    
    final_tempo_sparse_vec<-c(final_tempo_sparse_vec,tempo_sparse_vec)
    final_tempo_Abin_vec<-c(final_tempo_Abin_vec,tempo_Abin_vec)
    final_tempo_Bbin_vec<-c(final_tempo_Bbin_vec, tempo_Bbin_vec)
  }

# each sparse_table will have a 3 column data frame : score, binA, binB. 

tempo_df<-data.frame(C1_name=final_tempo_sparse_vec,
                     C2_name=final_tempo_Abin_vec,
                     C3_name=final_tempo_Bbin_vec)

colnames(tempo_df)<-c(paste(vec_dataset_names[i],"Score",sep=""),"BinA","BinB")

  if(WITH_OAS==TRUE){
  nam_table<-paste("KB100_",vec_dataset_names[i],"_Initial_Score_df",sep="")
  assign(nam_table, tempo_df)
  }else{
  nam_table<-paste("KB100_NO_OAS_",vec_dataset_names[i],"_Initial_Score_df",sep="")
  assign(nam_table, tempo_df)
  }



df_list<-append(df_list,tempo_df)

      if(WITH_OAS==TRUE){
        nam_df_list<-"KB100_Initial_Score_list"
        assign(nam_df_list, df_list)
  
      }else{
        nam_df_list<-"KB100_NO_OAS_Initial_Score_list"
        assign(nam_df_list, df_list)

      }
}

 if(WITH_OAS==TRUE){
   return(KB100_Initial_Score_list)
 }else{
   return(KB100_NO_OAS_Initial_Score_list)
 }
}

```

This function will output a list of 15 clumns , each three coluns are ex: wtns,binA,binB,wts,binA,binB,kons,...
The binA and binB are the same. 

Now we can build the tables : 

```{r Execution : Get KB100 and KB100_NO_OAS Score_df}

#Get Initial_Score_df 

KB100_Initial_Score_list<-GetKB100ScoreTable(TRUE)
KB100_NO_OAS_Initial_Score_list<-GetKB100ScoreTable(FALSE)

# Build score vectors 
#KNOS TO CHANGE BY KONS

    #KB100
KB100_Wtns_Sparse_Matrix_Vector<-GetCleanVector(KB100_Initial_Score_list[[1]])
KB100_Wts_Sparse_Matrix_Vector<-GetCleanVector(KB100_Initial_Score_list[[4]])
KB100_Kons_Sparse_Matrix_Vector<-GetCleanVector(KB100_Initial_Score_list[[7]])
KB100_Kos_Sparse_Matrix_Vector<-GetCleanVector(KB100_Initial_Score_list[[10]])
KB100_Published_Sparse_Matrix_Vector<-GetCleanVector(KB100_Initial_Score_list[[13]])
KB100_binA<-GetCleanVector(KB100_Initial_Score_list[[14]])
KB100_binB<-GetCleanVector(KB100_Initial_Score_list[[15]])


    #KB100_NO_OAS
KB100_NO_OAS_Wtns_Sparse_Matrix_Vector<-GetCleanVector(KB100_NO_OAS_Initial_Score_list[[1]])
KB100_NO_OAS_Wts_Sparse_Matrix_Vector<-GetCleanVector(KB100_NO_OAS_Initial_Score_list[[4]])
KB100_NO_OAS_Kons_Sparse_Matrix_Vector<-GetCleanVector(KB100_NO_OAS_Initial_Score_list[[7]])
KB100_NO_OAS_Kos_Sparse_Matrix_Vector<-GetCleanVector(KB100_NO_OAS_Initial_Score_list[[10]])
KB100_NO_OAS_Published_Sparse_Matrix_Vector<-GetCleanVector(KB100_NO_OAS_Initial_Score_list[[13]])
KB100_NO_OAS_binA<-KB100_NO_OAS_Initial_Score_list[[14]]
KB100_NO_OAS_binB<-KB100_NO_OAS_Initial_Score_list[[15]]


# Build The Final KB100_Score_df  :

    #KB100
KB100_Score_df<-data.frame(
  WTNS=KB100_Wtns_Sparse_Matrix_Vector, 
  WTS=KB100_Wts_Sparse_Matrix_Vector, 
  KONS=KB100_Kons_Sparse_Matrix_Vector, 
  KOS=KB100_Kos_Sparse_Matrix_Vector, 
  PUBLISHED=KB100_Published_Sparse_Matrix_Vector,
  FC_wts_wtns=log2(KB100_Wts_Sparse_Matrix_Vector/KB100_Wtns_Sparse_Matrix_Vector),
  FC_kos_kons=log2(KB100_Kos_Sparse_Matrix_Vector/KB100_Kons_Sparse_Matrix_Vector),
  FC_wtns_kons=log2(KB100_Wtns_Sparse_Matrix_Vector/KB100_Kons_Sparse_Matrix_Vector),
  FC_wts_kos=log2(KB100_Wts_Sparse_Matrix_Vector/KB100_Kos_Sparse_Matrix_Vector),
  A_BIN=KB100_binA,
  B_BIN=KB100_binB)

colnames(KB100_Score_df)<-FC_DF_COLNAMES

    #KB100_NO_OAS
KB100_NO_OAS_Score_df<-data.frame(
  WTNS=KB100_NO_OAS_Wtns_Sparse_Matrix_Vector, 
  WTS=KB100_NO_OAS_Wts_Sparse_Matrix_Vector, 
  KONS=KB100_NO_OAS_Kons_Sparse_Matrix_Vector, 
  KOS=KB100_NO_OAS_Kos_Sparse_Matrix_Vector, 
  PUBLISHED=KB100_NO_OAS_Published_Sparse_Matrix_Vector,
  FC_wts_wtns=log2(KB100_NO_OAS_Wts_Sparse_Matrix_Vector/KB100_NO_OAS_Wtns_Sparse_Matrix_Vector),
  FC_kos_kons=log2(KB100_NO_OAS_Kos_Sparse_Matrix_Vector/KB100_NO_OAS_Kons_Sparse_Matrix_Vector),
  FC_wtns_kons=log2(KB100_NO_OAS_Wtns_Sparse_Matrix_Vector/KB100_NO_OAS_Kons_Sparse_Matrix_Vector),
  FC_wts_kos=log2(KB100_NO_OAS_Wts_Sparse_Matrix_Vector/KB100_NO_OAS_Kos_Sparse_Matrix_Vector),
  A_BIN=KB100_NO_OAS_binA,
  B_BIN=KB100_NO_OAS_binB)

colnames(KB100_NO_OAS_Score_df)<-FC_DF_COLNAMES

```


# V. Data Analysis 

## 1. Desnity plots of Full Change scores to expect the distribution of our data. 

```{r Plots : Distribution of log(Full Change) scores}
list_Score_dataframes<-list(AllMatrix_Score_df,Cluster_Score_df, KB100_NO_OAS_Score_df, KB100_NO_OAS_Score_df)

#AllMatrix
par(mfrow=c(3,2),oma = c(0, 0, 4, 0))
hist(as.numeric(as.data.frame(list_Score_dataframes[[1]])$WTNS), main="WTNS", xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[1]])$WTS), main="WTS", xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[1]])$KONS), main="KONS", xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[1]])$KOS), main="KOS", xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[1]])$FC_wts_wtns),main="FC_wts_wtns",xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[1]])$FC_kos_kons), main="FC_kos_kons", xlab="Score",ylab="Density")
mtext("AllMatrix scores distribution",outer = TRUE)


#Cluster 
par(mfrow=c(3,2),oma = c(0, 0, 4, 0))
hist(as.numeric(as.data.frame(list_Score_dataframes[[2]])$WTNS), main="WTNS", xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[2]])$WTS), main="WTS", xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[2]])$KONS), main="KONS", xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[2]])$KOS), main="KOS", xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[2]])$FC_wts_wtns),main="FC_wts_wtns",xlab="Score",ylab="Density")
hist(as.numeric(as.data.frame(list_Score_dataframes[[2]])$FC_kos_kons), main="FC_kos_kons", xlab="Score",ylab="Density")
mtext("Cluster scores distribution",outer = TRUE)


```

One Can see that FC vectors seem to have Normal Distribution in both samples (Cluster And AllMatrix)

## 2. Normality test for our score_df tables 
Shapiro test can be done because of the length of our data vectors (>5000 values)

i. We chose to do the Kolmogorov-Smirnov Normality test
Remark : No Ex_aquo should be present to KS test.

```{r Kolmogorov-Smirnov Test:  Verify Normality of log(FC) obtained vectors }

AllMatrix_KS_pval<-vector()
AllMatrix_KS_pval<-c(
ks.test((unique(as.data.frame(list_Score_dataframes[[1]])$FC_wts_wtns)),"pnorm")$p.value,
ks.test((unique(as.data.frame(list_Score_dataframes[[1]])$FC_kos_kons)),"pnorm")$p.value)

Cluster_KS_pval<-vector()
Cluster_KS_pval<-c(
ks.test((unique(as.data.frame(list_Score_dataframes[[2]])$FC_wts_wtns)),"pnorm")$p.value,
ks.test((unique(as.data.frame(list_Score_dataframes[[2]])$FC_kos_kons)),"pnorm")$p.value)

# Kolmogorov-Smirnov Normality test results
KS_df_rownames<-c("FC_wts_wtns", "FC_kos_kons")
KS_df<-data.frame(Condition=KS_df_rownames,AllMatrix_KS_pval,Cluster_KS_pval)

KS_df
```

```{r Lillifors : retest normality of FC_wts_wtns and FC_kos_kons}

m1<-lillie.test( AllMatrix_Score_df$FC_wts_wtns )$p.value
m2<-lillie.test( AllMatrix_Score_df$FC_kos_kons )$p.value
c1<-lillie.test( Cluster_Score_df$FC_wts_wtns )$p.value
c2<-lillie.test( Cluster_Score_df$FC_kos_kons )$p.value
k1<-lillie.test( KB100_Score_df$FC_wts_wtns)$p.value
k2<-lillie.test( KB100_Score_df$FC_kos_kons)$p.value
kn1<-lillie.test( KB100_NO_OAS_Score_df$FC_wts_wtns)$p.value
kn2<-lillie.test( KB100_NO_OAS_Score_df$FC_kos_kons)$p.value

df_lillie.test<-data.frame(c(m1,m2),c(c1,c2),c(k1,k2),c(kn1,kn2))
colnames(df_lillie.test)<-vec_sample_names
df_lillie.test

```


```{r Execution : Save K-S and L tests results}
setwd(Dir_Figures)

write.table(KS_df, "Kolmogorov_Smirnov_Normality_test_results.txt" , sep="\t", row.names=FALSE,col.names=TRUE,quote=FALSE)

write.table(df_lillie.test, "Lillifors_Normality_test_results.txt" , sep="\t", row.names=FALSE,col.names=TRUE,quote=FALSE)

```


P.values are <<0.01. FC_wts_wtns and FC_kos_kons distributions are normal. We can use the t.test. 

```{r Statistical test :t.test: intrasample FC_wts_wtns VS FC_kons_kos}

t.test(AllMatrix_Score_df$FC_wts_wtns,AllMatrix_Score_df$FC_kos_kons,paired=TRUE)

t.test(Cluster_Score_df$FC_wts_wtns,Cluster_Score_df$FC_kos_kons,paired=TRUE)

```

Observation :
In the Cluster, significant difference between FC_wts_wtns and FC_kos_kons (p=0.09).
No significant difference between the same vectors in the AllMatrix data.

## 3. Vilon Plots Intra Inter 
### a. IntraSample Violin Plots

```{r Function :  Violin Plots IntraSample : wts_wtns VS kos_kons with t.test p.values}

# 1 VIOLINPLOT Of wts_wtns each sample 
violin_fc_names<-c("violin_fc_cluster", "violin_fc_allmatrix", "violin_fc_100kb" , "violin_fc_100kb_No_OAS")

    #a. Preparing Violin Plot Dataframe
GetViolinFCPlotINTRA<- function (SCORE_DF ,  SAMPLE_NAME, TEST){

if(TEST=="t.test"){
  test<-'t.test'
}else{
  test<-'wilcox.test'
}
  
working.table<-SCORE_DF
wts_wtns_vec_name<-rep("wts_wtns",nrow(working.table))
kos_kons_vec_name<-rep("kos_kons",nrow(working.table))
wts_wtns_FC<-working.table[,6]
kos_kons_FC<-working.table[,7]
df<-data.frame(c(wts_wtns_vec_name,kos_kons_vec_name),c(wts_wtns_FC,kos_kons_FC))
colnames(df)<-c("C1","C2")

    #b. preparing to show the p.values on the plot 
df$C1 <- as.factor(df$C1)
my_comparisons <- list( c("wts_wtns", "kos_kons") ) 
df_test <- compare_means(C2 ~ C1, comparisons = my_comparisons, p.adj= "holm", method=test, data = df , paired=TRUE)
df_test <- df_test %>% mutate(y.position = max(df$C2)+0.5)
df_test$p.adj<-format(df_test$p.adj, scientific=TRUE )

    #c. Generating the violin plot : intrasample - wts_wtns VS kos_kons
violin_plot<- df %>% ggplot(aes(C1, C2)) +
  
  geom_violin(aes(fill=C1)) + 
  geom_boxplot(width=0.1, fill="white") + 
  xlab(c("")) + 
  ggtitle(SAMPLE_NAME ) +  
  theme(plot.title = element_text(hjust = 0.5)) +
  guides(fill=guide_legend(title="")) +
  ylab("Score (log2(FC))") + ylim(c(-3,5)) +
  
  scale_x_discrete(limits=c("wts_wtns","kos_kons")) + 
  scale_fill_discrete(guide = guide_legend(reverse=TRUE) ) + 
  scale_fill_brewer(palette=palette_color) + 

  stat_pvalue_manual(df_test, label = "p.adj") 


if(SAMPLE_NAME=="Cluster"){violin_plot<-violin_plot+ theme(legend.position="none")}
if(SAMPLE_NAME=="100kb"){violin_plot<-violin_plot + theme(legend.position="none") }
if(SAMPLE_NAME=="100kb NO OAS"){violin_plot<-violin_plot + theme(legend.position="right") 

}

    #d. Wilcoxon test resume
test_details<- lm(C2~C1, data=df)

return(list(violin_plot,test_details))
}


```

Plots :

```{r Plots -T.test- : Intrasample Violin Plots : Comparing FC_wts_wtns and FC_kos_kons in each sample , message=FALSE, warning=FALSE}
        #a. define violin plots variables 
violin_fc_allmatrix_ttest<-GetViolinFCPlotINTRA(AllMatrix_Score_df , "All Matrix","t.test")[[1]]
violin_fc_cluster_ttest<-GetViolinFCPlotINTRA(Cluster_Score_df, "Cluster","t.test")[[1]]
violin_fc_KB100_ttest<-GetViolinFCPlotINTRA(KB100_Score_df, "KB100" ,"t.test")[[1]]
violin_fc_KB100_NO_OAS_ttest<-GetViolinFCPlotINTRA(KB100_NO_OAS_Score_df , "KB_NO_OAS","t.test")[[1]]

        #b. Display Violin plots 
grid_arrange_shared_legend( violin_fc_cluster_ttest, violin_fc_KB100_ttest, violin_fc_KB100_NO_OAS_ttest, ncol=3 , nrow=1 , top="Full Change Violin Plots -T.Test-")

```   

```{r Plots -Wilcoxon.test- : Intrasample Violin Plots : Comparing FC_wts_wtns and FC_kos_kons in each sample , message=FALSE, warning=FALSE}
        #a. define violin plots variables 
violin_fc_allmatrix_wtest<-GetViolinFCPlotINTRA(AllMatrix_Score_df , "All Matrix","wilcox.test")[[1]]
violin_fc_cluster_wtest<-GetViolinFCPlotINTRA(Cluster_Score_df, "Cluster","wilcox.test")[[1]]
violin_fc_KB100_wtest<-GetViolinFCPlotINTRA(KB100_Score_df, "KB100" ,"wilcox.test")[[1]]
violin_fc_KB100_NO_OAS_wtest<-GetViolinFCPlotINTRA(KB100_NO_OAS_Score_df , "KB_NO_OAS","wilcox.test")[[1]]

        #b. Display Violin plots 
grid_arrange_shared_legend( violin_fc_cluster_wtest, violin_fc_KB100_wtest, violin_fc_KB100_NO_OAS_wtest, ncol=3 , nrow=1 , top="Full Change Violin Plots -Wilcoxon.Test-")

```   

Results of the chosen statistical test :

```{r T.Test : results obtained on the violin plots , warning=FALSE, message=FALSE}

        #e. define violin plots t.test outputs

violin_fc_allmatrix_ttest_results<-GetViolinFCPlotINTRA(AllMatrix_Score_df , "All Matrix" , "t.test")[[2]]
violin_fc_cluster_ttest_results<-GetViolinFCPlotINTRA(Cluster_Score_df, "Cluster", "t.test")[[2]]
violin_fc_KB100_ttest_results<-GetViolinFCPlotINTRA(KB100_Score_df, "100kb" , "t.test")[[2]]
violin_fc_KB100_NO_OAS_ttest_results<-GetViolinFCPlotINTRA(KB100_NO_OAS_Score_df, "100kb NO OAS", "t.test")[[2]]

```

```{r Wilcoxon Test : results obtained on the violin plots , warning=FALSE, message=FALSE}

        #e. define violin plots t.test outputs

violin_fc_allmatrix_wtest_results<-GetViolinFCPlotINTRA(AllMatrix_Score_df , "All Matrix" , "wilcox.test")[[2]]
violin_fc_cluster_wtest_results<-GetViolinFCPlotINTRA(Cluster_Score_df, "Cluster", "wilcox.test")[[2]]
violin_fc_KB100_wtest_results<-GetViolinFCPlotINTRA(KB100_Score_df, "100kb" , "wilcox.test")[[2]]
violin_fc_KB100_NO_OAS_wtest_results<-GetViolinFCPlotINTRA(KB100_NO_OAS_Score_df, "100kb NO OAS", "wilcox.test")[[2]]

```

Verifying the t.test results manually : 

```{r T.test : Manually on intrasmaple FC_wts_wtns and FC_kos_kons vectors.}

a<-t.test(AllMatrix_Score_df$FC_wts_wtns , AllMatrix_Score_df$FC_kos_kons, paired=TRUE)$p.value
b<-t.test(Cluster_Score_df$FC_wts_wtns , Cluster_Score_df$FC_kos_kons, paired=TRUE)$p.value
c<-t.test(KB100_Score_df$FC_wts_wtns , KB100_Score_df$FC_kos_kons, paired=TRUE)$p.value
d<-t.test(KB100_NO_OAS_Score_df$FC_wts_wtns , KB100_NO_OAS_Score_df$FC_kos_kons, paired=TRUE)$p.value

df_intrasample_t.test<-c(a,b,c,d)
names(df_intrasample_t.test)<-c("AllMatrix" , "Cluster" , "KB100" , "KB100_NO_OAS")

df_intrasample_t.test
```

```{r Wilcoxon Test : Manually on intrasmaple FC_wts_wtns and FC_kos_kons vectors.}

aw<-wilcox.test(AllMatrix_Score_df$FC_wts_wtns , AllMatrix_Score_df$FC_kos_kons, paired=TRUE)$p.value
bw<-wilcox.test(Cluster_Score_df$FC_wts_wtns , Cluster_Score_df$FC_kos_kons, paired=TRUE)$p.value
cw<-wilcox.test(KB100_Score_df$FC_wts_wtns , KB100_Score_df$FC_kos_kons, paired=TRUE)$p.value
dw<-wilcox.test(KB100_NO_OAS_Score_df$FC_wts_wtns , KB100_NO_OAS_Score_df$FC_kos_kons, paired=TRUE)$p.value

df_intrasample_w.test<-c(aw,bw,cw,dw)
names(df_intrasample_w.test)<-c("AllMatrix" , "Cluster" , "KB100" , "KB100_NO_OAS")

df_intrasample_w.test
```

```{r Execution : Save Each Plot Seperately}

# T.Test plots 

ggsave(filename=paste("violin_fc_allmatrix_ttest",".png",sep=""), plot = violin_fc_allmatrix_ttest , path=Dir_Figures, dpi=320)

ggsave(filename=paste("violin_fc_cluster_ttest",".png",sep=""), plot = violin_fc_cluster_ttest , path=Dir_Figures, dpi=320)

ggsave(filename=paste("violin_fc_KB100_ttest",".png",sep=""), plot = violin_fc_KB100_ttest , path=Dir_Figures, dpi=320)

ggsave(filename=paste("violin_fc_KB100_NO_OAS_ttest",".png",sep=""), plot = violin_fc_KB100_NO_OAS_ttest , path=Dir_Figures, dpi=320)

#  Wilcoxon Plots

ggsave(filename=paste("violin_fc_allmatrix_wtest",".png",sep=""), plot = violin_fc_allmatrix_wtest , path=Dir_Figures, dpi=320)

ggsave(filename=paste("violin_fc_cluster_wtest",".png",sep=""), plot = violin_fc_cluster_wtest , path=Dir_Figures, dpi=320)

ggsave(filename=paste("violin_fc_KB100_wtest",".png",sep=""), plot = violin_fc_KB100_wtest , path=Dir_Figures, dpi=320)

ggsave(filename=paste("violin_fc_KB100_NO_OAS_wtest",".png",sep=""), plot = violin_fc_KB100_NO_OAS_wtest , path=Dir_Figures, dpi=320)


```


### b. InterSample Violin Plots 

Violin Plots InterSample : wts_wtns VS kos_kons
wilcoxon with paired =FALSE beacause different length of the samples. 

- Build dataframe of intersample : only 3 columns : C1=w or k ; C2=score ; C3=Sample
- Build 3 data frames of 3 columns (one for each SAMPLE) then merge rows

we exclude the all matrix data frame (note useful)

```{r Execution : Building input dataframes needed }

    #a. Building sample specific dataframe according to ggplot : 3 columns ={"wts_wtns"/"kos_kons" ; score ; Sample}

vec_name_df_sample<-vector()
list_df_sample<-list()

for(i in 1:length(list_Score_dataframes)){
  working.table<-as.data.frame(list_Score_dataframes[i])
  wts_wtns_vec_name<-rep("wts_wtns",nrow(working.table))
  kos_kons_vec_name<-rep("kos_knos",nrow(working.table))
  wts_wtns_FC<-working.table[,6]
  kos_kons_FC<-working.table[,7]

  sample_name<-rep(vec_sample_names[i], length(c(wts_wtns_vec_name,kos_kons_vec_name)))
  
  df<-data.frame(c(wts_wtns_vec_name,kos_kons_vec_name),c(wts_wtns_FC,kos_kons_FC),sample_name)
  
  nam<-paste("df_",vec_sample_names[i], sep="")
  assign(nam , df)
  
  vec_name_df_sample<-c(vec_name_df_sample,nam)
}
# -> We end up with three data frames : {df_ALLMATRIX ; df_CLUSTER ; df_KB100 ;df_KB100_NO_OAS } : 
list.working.table<-list(df_CLUSTER, df_ALLMATRIX , df_KB100,df_KB100_NO_OAS)
#Note : here we exclude A;;Matrix dataframe. To add it, just add "df_ALLMATRIX" as the first variable of the list.working.table.

    #b. merge the 4 tables vertically 
vec_name_df_sample_without_allmatrix<-c("CLUSTER"    ,"KB100"      ,  "KB100_NO_OAS")

global_df_col1<-c() ; global_df_col2<-c() ; global_df_col3<-c()

for(i in 1:length(vec_name_df_sample)){
  working.table<-as.data.frame(list.working.table[i])
  global_df_col1<-c(global_df_col1,working.table[,1])
  global_df_col2<-c(global_df_col2,working.table[,2])
  global_df_col3<-c(global_df_col3,working.table[,3])
}

global_vertical_FC_df<-data.frame(
  Condition=global_df_col1,
  FC_scores=global_df_col2,
  Sample=global_df_col3)

```

As we need to compare FC_wts_wtns data between different sample and to do the same for FC_kos_kons between the different conditions, we need two different tables : one for FC_wts_wtns and one for FC_kos_kons. 

```{r Execution : Prepare needed dataframes for each condition : FC_wts_wtns and FC_kos_kons}

global_vertical_FC_df_wts_wtns<- global_vertical_FC_df %>% filter(Condition=="wts_wtns") %>% filter (Sample %in% c("CLUSTER" ,"KB100", "KB100_NO_OAS")) 

global_vertical_FC_df_kos_kons<- global_vertical_FC_df %>% filter(Condition!="wts_wtns") %>% filter (Sample %in% c("CLUSTER" ,"KB100", "KB100_NO_OAS")) 

```

In the intersample comparaison, the parameter paired is turned to FALSE because of the different nrow of each datatable. 

```{r Plots -Wilcoxon.test- : Intersample Violin Plots for FC_wts_wtns and FC_kos_kons.}

GetInterSampleVilonPlot<-function (TEST){

if(TEST=="t.test"){
  test<-"t.test"
  plot_main_title<-"Intersample Full Change Violin Plots -T.Test-"
}else{
  test<-"wilcox.test"
  plot_main_title<-"Intersample Full Change Violin Plots -Wilcoxon.Test-"
}


my_comparisons <- list( c("CLUSTER", "KB100") ,c("CLUSTER", "KB100_NO_OAS") , c( "KB100", "KB100_NO_OAS")) 

            #wts_wtns
df_test_w <- compare_means(FC_scores ~ Sample, comparisons = my_comparisons, p.adj= "holm", method=test, data = global_vertical_FC_df_wts_wtns , paired=FALSE)
df_test_w <- df_test_w %>% mutate(y.position = c(5,6,4))

            #kos_kons
df_test_k <- compare_means(FC_scores ~ Sample, comparisons = my_comparisons, p.adj= "holm", method=test, data = global_vertical_FC_df_kos_kons , paired=FALSE)
df_test_k <- df_test_k %>% mutate(y.position = c(5,6,4))


    # Generating the violin plots : intersample

            #wts_wtns
Inter_sample_FC_violin_plot_w<-global_vertical_FC_df_wts_wtns %>% ggplot(aes(Sample, FC_scores)) + geom_violin(aes(fill=Sample))    + 
geom_boxplot(width=0.1) +
scale_x_discrete(limits=vec_name_df_sample_without_allmatrix) + 
xlab(c("")) +  ggtitle("FC_Wts_Wtns") + 
   theme(plot.title = element_text(hjust = 0.5)) + 
   scale_fill_discrete(guide = guide_legend(reverse=TRUE) ) + 
   guides(fill=guide_legend(title="")) +
   ylab("")  + ylim(c(-3,6))+
  stat_pvalue_manual(df_test_w, label = "p.format")

            #kos_kons
Inter_sample_FC_violin_plot_k <- global_vertical_FC_df_kos_kons %>% ggplot(aes(Sample, FC_scores)) + geom_violin(aes(fill=Sample))    + 
geom_boxplot(width=0.1) +
scale_x_discrete(limits=vec_name_df_sample_without_allmatrix) + 
xlab(c("")) +  ggtitle("FC_Kos_Kons" ) + 
   theme(plot.title = element_text(hjust = 0.5)) + 
   scale_fill_discrete(guide = guide_legend(reverse=TRUE) ) + 
   guides(fill=guide_legend(title="")) +
   ylab("")  + ylim(c(-3,6))+
  stat_pvalue_manual(df_test_k, label = "p.format")


        #.Display Violin plots 

return(grid_arrange_shared_legend( Inter_sample_FC_violin_plot_w, Inter_sample_FC_violin_plot_k, ncol=2 , nrow=1 , top=plot_main_title))
}
```

```{r Plots : Intersample violin plots with t.test ans wilcoxon p.values}
#t.test p.values
GetInterSampleVilonPlot("t.test")

#wilcoxon p.values
GetInterSampleVilonPlot("wilcox.test")

```

```{r T.Test : Verification of p.values shown in the plot}
#FC_wts_wtns
at1<-t.test(Cluster_Score_df$FC_wts_wtns , KB100_Score_df$FC_wts_wtns ,paires=FALSE)$p.value
bt1<-t.test(Cluster_Score_df$FC_wts_wtns , KB100_NO_OAS_Score_df$FC_wts_wtns ,paires=FALSE)$p.value
ct1<-t.test(KB100_Score_df$FC_wts_wtns , KB100_NO_OAS_Score_df$FC_wts_wtns ,paires=FALSE)$p.value
df_intersample_wt.ttest<-c(at1,bt1,ct1)
names(df_intersample_wt.ttest)<-c("CLUSTER|KB100" , "CLUSTER|KB100_NO_OAS" ,"KB100|KB100_NO_OAS")


#FC_kos_kons
at2<-t.test(Cluster_Score_df$FC_kos_kons , KB100_Score_df$FC_kos_kons ,paires=FALSE)$p.value
bt2<-t.test(Cluster_Score_df$FC_kos_kons , KB100_NO_OAS_Score_df$FC_kos_kons ,paires=FALSE)$p.value
ct2<-t.test(KB100_Score_df$FC_kos_kons , KB100_NO_OAS_Score_df$FC_kos_kons ,paires=FALSE)$p.value
df_intersample_ko.ttest<-c(at2,bt2,ct2)
names(df_intersample_ko.ttest)<-c("CLUSTER|KB100" , "CLUSTER|KB100_NO_OAS" ,"KB100|KB100_NO_OAS")


#display the p.values of each test
list(t.test_pvalues_FC_wts_wtns=df_intersample_wt.ttest, t.test_pvalues_FC_kos_kons=df_intersample_ko.ttest)

```

```{r Wilcoxon Test : Verification of p.values shown in the plot}
#FC_wts_wtns
aw1<-wilcox.test(Cluster_Score_df$FC_wts_wtns , KB100_Score_df$FC_wts_wtns ,paires=FALSE)$p.value
bw1<-wilcox.test(Cluster_Score_df$FC_wts_wtns , KB100_NO_OAS_Score_df$FC_wts_wtns ,paires=FALSE)$p.value
cw1<-wilcox.test(KB100_Score_df$FC_wts_wtns , KB100_NO_OAS_Score_df$FC_wts_wtns ,paires=FALSE)$p.value
df_intersample_wt.wtest<-c(aw1,bw1,cw1)
names(df_intersample_wt.wtest)<-c("CLUSTER|KB100" , "CLUSTER|KB100_NO_OAS" ,"KB100|KB100_NO_OAS")


#FC_kos_kons
aw2<-t.test(Cluster_Score_df$FC_kos_kons , KB100_Score_df$FC_kos_kons ,paires=FALSE)$p.value
bw2<-t.test(Cluster_Score_df$FC_kos_kons , KB100_NO_OAS_Score_df$FC_kos_kons ,paires=FALSE)$p.value
cw2<-t.test(KB100_Score_df$FC_kos_kons , KB100_NO_OAS_Score_df$FC_kos_kons ,paires=FALSE)$p.value
df_intersample_ko.wtest<-c(aw2,bw2,cw2)
names(df_intersample_ko.wtest)<-c("CLUSTER|KB100" , "CLUSTER|KB100_NO_OAS" ,"KB100|KB100_NO_OAS")

#display the p.values of each test
list(w.test_pvalues_FC_wts_wtns=df_intersample_wt.wtest, w.test_pvalues_FC_kos_kons=df_intersample_ko.wtest)
```

# VI. Heatmaps 

```{r Defining Plots : Heatmaps}
# All matrix 

    # FC Scores
Heatmap_AllMatrix_FC_WT  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=FC_wts_wtns)) + geom_tile() + ggtitle("All Matrix Wts/Wtns Full Change Heatmap") + scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3", limits=c(-2.5,2.5)) +
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()
                                                                                          
Heatmap_AllMatrix_FC_KO  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=FC_kos_kons)) + geom_tile() + ggtitle("All Matrix Kos/Kons Full Change Heatmap") + 
  scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3", limits=c(-2.5,2.5)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_AllMatrix_FC_WTNS_KONS  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=FC_wtns_kons)) + geom_tile() + ggtitle("All Matrix Wtns/Kons Full Change Heatmap") + 
  scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3", limits=c(-2.5,2.5)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_AllMatrix_FC_WTS_KOS  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=FC_wts_kos)) + geom_tile() + ggtitle("All Matrix Wts/Kos Full Change Heatmap") + 
  scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3", limits=c(-2.5,2.5)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

    # Scores 

Heatmap_AllMatrix_WTNS  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=WTNS)) + geom_tile() + ggtitle("All Matrix WTNS Heatmap") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_AllMatrix_WTS  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=WTS)) + geom_tile() + ggtitle("All Matrix WTS Heatmap") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_AllMatrix_KONS  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=KONS)) + geom_tile() + ggtitle("All Matrix KONS Heatmap") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_AllMatrix_KOS  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=KOS)) + geom_tile() + ggtitle("All Matrix KOS Heatmap") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_AllMatrix_PUBLISHED  <-AllMatrix_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=PUBLISHED)) + geom_tile() + ggtitle("All Matrix PUBLISHED Heatmap") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()


#Cluster 
  
    # FC

Heatmap_Cluster_FC_WT  <-Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=FC_wts_wtns)) + geom_tile() + ggtitle("All Matrix Wts/Wtns Full Change Heatmap") + scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3", limits=c(-2.5,2.5)) +
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_Cluster_FC_KO  <-Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=FC_kos_kons)) + geom_tile() + ggtitle("Cluster Kos/Kons Full Change Heatmap") + scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3", limits=c(-2.5,2.5)) +
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_Cluster_FC_WTNS_KONS  <-Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=FC_wtns_kons)) + geom_tile() + ggtitle("Cluster Wtns/Kons Full Change Heatmap") + 
  scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3", limits=c(-2.5,2.5)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

Heatmap_Cluster_FC_WTS_KOS  <-Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=FC_wts_kos)) + geom_tile() + ggtitle("Cluster Wts/Kos Full Change Heatmap") + 
  scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3", limits=c(-2.5,2.5)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) + coord_fixed()

    # Scores

Heatmap_Cluster_WTNS<- Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=WTNS)) + geom_tile() + 
  ggtitle("Cluster Heatmap - WTNS Data") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) +
  coord_fixed()

Heatmap_Cluster_WTS<- Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=WTS)) + geom_tile() + 
  ggtitle("Cluster Heatmap - WTS Data") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) +
  coord_fixed()

Heatmap_Cluster_KONS<- Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=KONS)) + geom_tile() + 
  ggtitle("Cluster Heatmap - KONS Data") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) +
  coord_fixed()

Heatmap_Cluster_KOS<- Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=KOS)) + geom_tile() + 
  ggtitle("Cluster Heatmap - KOS Data") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) +
  coord_fixed()

Heatmap_Cluster_PUBLISHED<- Cluster_Score_df %>% ggplot(aes(A_BIN, B_BIN, fill=PUBLISHED)) + geom_tile() + 
  ggtitle("Cluster Heatmap - PUBLISHED Data") + 
  scale_fill_gradientn(colours=c("white","#FF0000"), na.value="#DAD7D3",limits = c(0,0.02)) +   
  theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank()) +
  coord_fixed()

#Added for all matrix : two columns : FC_wtns_kons , FC_wts_kos

```

```{r Function : Save all plots }

SaveHeatmap<-function(DIRECTORY , PLOT, OUTPUT_NAME){
  setwd(DIRECTORY)
  ggsave(filename=paste(OUTPUT_NAME,".png",sep=""),
         device="png",
         plot=PLOT,
         scale = 1, 
         dpi=320)
}

```

```{r Execution : Save Heatmaps }

list_AllMatrix_AllHeatmaps<-list (Heatmap_AllMatrix_WTNS, Heatmap_AllMatrix_WTS, Heatmap_AllMatrix_KONS, Heatmap_AllMatrix_KOS, Heatmap_AllMatrix_PUBLISHED, Heatmap_AllMatrix_FC_WT, Heatmap_AllMatrix_FC_KO, Heatmap_AllMatrix_FC_WTNS_KONS, Heatmap_AllMatrix_FC_WTS_KOS)

list_AllMatrix_AllHeatmaps_Names<-list ("Heatmap_AllMatrix_WTNS", "Heatmap_AllMatrix_WTS", "Heatmap_AllMatrix_KONS", "Heatmap_AllMatrix_KOS", "Heatmap_AllMatrix_PUBLISHED", "Heatmap_AllMatrix_FC_WT", "Heatmap_AllMatrix_FC_KO" , "Heatmap_AllMatrix_FC_WTNS_KONS" , "Heatmap_AllMatrix_FC_WTS_KOS")


list_Cluster_AllHeatmaps<-list(Heatmap_Cluster_WTNS , Heatmap_Cluster_WTS,Heatmap_Cluster_KONS, Heatmap_Cluster_KOS, Heatmap_Cluster_PUBLISHED, Heatmap_Cluster_FC_WT  , Heatmap_Cluster_FC_KO, Heatmap_Cluster_FC_WTNS_KONS, Heatmap_Cluster_FC_WTS_KOS )

list_Cluster_AllHeatmaps_Names<-list("Heatmap_Cluster_WTNS" , "Heatmap_Cluster_WTS","Heatmap_Cluster_KONS", "Heatmap_Cluster_KOS", "Heatmap_Cluster_PUBLISHED", "Heatmap_Cluster_FC_WT"  , "Heatmap_Cluster_FC_KO", "Heatmap_Cluster_FC_WTNS_KONS", "Heatmap_Cluster_FC_WTS_KOS")


for(i in 1:length(list_AllMatrix_AllHeatmaps_Names)){
  ggsave(filename=paste(list_AllMatrix_AllHeatmaps_Names[i],".png",sep=""), plot = list_AllMatrix_AllHeatmaps[[i]], path=Dir_Figures , dpi=320)
}

for(i in 1:length(list_Cluster_AllHeatmaps_Names)){
  ggsave(filename=paste(list_Cluster_AllHeatmaps_Names[i],".png",sep=""), plot = list_Cluster_AllHeatmaps[[i]], path=Dir_Figures, dpi=320)
}


```





















